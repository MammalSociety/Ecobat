## create lists to be used for tables and graphs later:
# list of all of the unique locations in the dataset
Dets <- c(unique(All_data$location_name))
# list of all of the different species in the dataset
species_list <- unique(All_data$species)
Spp_list <- unique(All_data$Spp)
# dataframe of survey days
Surv.days <- as.data.frame(unique(All_data$Night)) #all unique survey nights
Surv.days.N <- length(Surv.days$`unique(All_data$Night)`) #count of survey nights
Surv.days.M <- Surv.days %>%
mutate(Month = lubridate::month((unique(All_data$Night)), label = T)) %>%
dplyr::count(Month) #count of survey days per month
# get a colour-blind friendly colour palette for graphs
colourCount <- length(unique(All_data$Spp))
getPalette <- colorRampPalette(brewer.pal(9, "RdBu"))
# set colour palette for activity levels in graphs
cbbPalette <- c("#D55E00", "#0072B2","#56B4E9","#009E73","#E69F00")
# specify order for the species to be listed in
All_data$Spp <- factor(All_data$Spp,levels=c("Pipistrellus", "Common pipistrelle", "Soprano pipistrelle", "Nathusius'", "Noctule", "Leisler's", "Nyctalus", "Serotine", "Nyctaloid", "Brown long-eared", "Grey long-eared", "Long-eared bats", "Myotis","Alcathoe", "Bechstein's",  "Brandt's", "Daubenton's","Whiskered", "Natterer's", "Barbastelle", "Greater horseshoe", "Lesser horseshoe", "Horseshoe bats"))
for (i in seq_len(length(unique(All_data$location_name)))) {
print(ggplot(All_data, aes(x=post_set_min, y=Spp, colour=Spp)) +
geom_segment(aes(x=lower, xend=upper, y=Spp, yend=Spp),
size = 25, colour="grey") +
geom_point(size=5, alpha=0.7,  position = position_jitter(height = 0.3)) +
xlab("\nTime after sunset (mins)") +
scale_x_continuous(breaks=c(-15, 0, 15, 30, 45, 60, 75, 90),
limits = c(-15, 90)) +
geom_hline(yintercept = c(seq_len(length(Spp_list)-1) + 0.5),
colour = "black", linetype = "dotted") +
scale_y_discrete(drop=TRUE) +
scale_colour_brewer(palette = "Paired") +
theme_bw() +
theme(legend.position = "none") +
theme(plot.caption = element_text(colour = "black", size = 34)) +
theme(strip.text.x = element_text(size=34, face="bold")) +
theme(axis.title.y = element_blank()) +
theme(axis.title.x = element_text(colour = "black", size = 34,
face = "bold")) +
theme(axis.text.x = element_text(size = 28, hjust=0.5, vjust=1,
colour = "black",
face = "bold")) +
theme(axis.text.y = element_text(size = 28, colour = "black",
face = "bold")) +
theme(panel.background = element_rect(fill = "white")) +
theme(panel.grid.major.x = element_line(colour = "black",
linetype = "dotted"),
panel.grid.minor.x = element_blank(),
panel.grid.major.y = element_blank(),
panel.grid.minor.y = element_blank()) +
theme(axis.ticks = element_blank()) +
facet_wrap_paginate(~location_name, ncol=1, nrow=1, page=i))
}
#### MATERNITY PERIOD ####
# need to repeat the above tables/graphs for the maternity period (15th June - 30th July) - but only if the survey was conducted over these days, so first we need to see if these dates are included in the data:
# add a column for Day-Month to be used to see if maternity period is included or not
sun_data$month <- lubridate::month(sun_data$Night, label = TRUE)
sun_data$nday <- lubridate::day(sun_data$Night)
sun_data$Day <- paste(sun_data$nday, sun_data$month, sep = "-")
# also add this to All_data
# ADDS CURRENT YEAR AS YEAR SO NEEDS CHANGING IN GGPLOT CODE BELOW AT THE TURN OF EACH NEW YEAR
All_data$month <- lubridate::month(All_data$Night)
All_data$nday <- lubridate::day(All_data$Night)
All_data$Day <- as.Date(paste(All_data$nday, All_data$month, sep = "-"), format = "%d-%m")
matern_days <- seq(as.Date("2019-06-15"), as.Date("2019-07-30"), by="days")
if (any(matern_days %in% All_data$Day)) {
paste("hello")
}
#### MATERNITY PERIOD ####
# need to repeat the above tables/graphs for the maternity period (15th June - 30th July) - but only if the survey was conducted over these days, so first we need to see if these dates are included in the data:
# add a column for Day-Month to be used to see if maternity period is included or not
# ADDS CURRENT YEAR AS YEAR SO NEEDS CHANGING IN GGPLOT CODE BELOW AT THE TURN OF EACH NEW YEAR
All_data$month <- lubridate::month(All_data$Night)
All_data$nday <- lubridate::day(All_data$Night)
All_data$Day <- as.Date(paste(All_data$nday, All_data$month, sep = "-"), format = "%d-%m") #misses year so puts the current year in
# create a vector of dates that fall within the maternity period
# remember to change the year to 2020 in the new year!!
matern_days <- seq(as.Date("2019-06-15"), as.Date("2019-07-30"), by="days")
# then we can say, if any of the maternity dates feature in the Day column of the dataframe, then we have data from within the maternity period so make a new table and graphs, if not, give a message there's no data within this period
if (any(matern_days %in% All_data$Day)) {
Maternity <- All_data %>%
dplyr::filter(Day >= "2019-06-15" & Day <= "2019-07-30") %>%
dplyr::filter(post_set_min <= upper) %>%
dplyr::group_by(Night, Spp, location_name) %>%
dplyr::count() %>%
spread(Night, n) %>%
dplyr::arrange(Spp, location_name) %>%
dplyr::rename("Detector ID" = location_name) %>%
dplyr::rename("Species" = Spp) %>%
replace(is.na(.), 0)
}
if (exists("Maternity") == TRUE){
if (any(is.na(Maternity$Species)) == FALSE) {
results='asis'
panderOptions('table.split.table', 100)
pander(Maternity, style = "multiline", justify = "left")
}
}
#NEEDS CHANGING EACH YEAR - so add 2020 on 01/01/2020 and 2021 on 01/01/2021 etc (due to the code 2 chunks above)
matern_data <- All_data %>%
dplyr::filter(Day >= "2019-06-15" & Day <= "2019-07-30")
if (any(matern_days %in% All_data$Day)) {
for (i in seq_len(length(unique(matern_data$location_name)))) {
print(matern_data %>%
ggplot(aes(x=post_set_min, y=Spp, colour=Spp)) +
geom_segment(aes(x=lower, xend=upper, y=Spp, yend=Spp),
size = 25, colour="grey") +
geom_point(size=5, alpha=0.7,
position = position_jitter(height = 0.3)) +
xlab("\nTime after sunset (mins)") +
scale_x_continuous(breaks=c(-15, 0, 15, 30, 45, 60, 75, 90),
limits = c(-15, 90)) +
geom_hline(yintercept = c(seq_len(length(Spp_list)-1) + 0.5),
colour = "black", linetype = "dotted") +
scale_y_discrete(drop=TRUE) +
scale_colour_brewer(palette = "Paired") +
theme_bw() +
theme(legend.position = "none") +
theme(plot.caption = element_text(colour = "black",
size = 34)) +
theme(strip.text.x = element_text(size=34, face="bold")) +
theme(axis.title.y = element_blank()) +
theme(axis.title.x = element_text(colour = "black", size = 34,
face = "bold")) +
theme(axis.text.x = element_text(size = 28, hjust=0.5, vjust=1,
colour = "black",
face = "bold")) +
theme(axis.text.y = element_text(size = 28, colour = "black",
face = "bold")) +
theme(panel.background = element_rect(fill = "white")) +
theme(panel.grid.major.x = element_line(colour = "black",
linetype = "dotted"),
panel.grid.minor.x = element_blank(),
panel.grid.major.y = element_blank(),
panel.grid.minor.y = element_blank()) +
theme (axis.ticks = element_blank()) +
facet_wrap_paginate(~location_name, nrow=1, ncol=1, page=i))
}
}
timediff <- difftime(max(df$Night),min(df$Night), units='days')
# PERCENTILES
# only select one of each group and remove time, this leaves a df where each row is a nightly summary (otherwise the number of passes is repeated for each individual pass)
df <- All_data %>%
dplyr::group_by(location_name, Night, Spp) %>%
dplyr::top_n(1) %>%
filter(row_number()==1) %>%
dplyr::select(-time)
df$location_name <- as.character(df$location_name)
recordsum <- ddply(df, c("location_name", "Spp"), summarise,
surv = length(species))
#now merge this back into the original csv - we don't want to delete any files at this stage
wp <- merge(df, recordsum, c("location_name","Spp")) #merge with original dataset - adds surv column onto end of dataset
# define some useful variables:
spn<-length(unique(df$Spp)) # no. of species
loc<-length(unique(df$location_name)) # no. of detectors
locs<-length(unique(df$site_name)) # no. of sites, should be 1
## the following "n_pages.." variables are used to get a number for how many pages facet_wrap_paginate needs to plot over for certain graphs. Basically work out how many individual graphs there will be, and divide by the number you want per page, and round UP using 'ceiling':
n_pages <- ceiling(nrow(unique(df[,c("species", "location_name")]))/8) # e.g. we have species and location plotted together and we want 8 graphs per page, so how many pages do we need? This will be "n_pages" - this becomes "i" in the 'for' function for facet_wrap_paginate
n_pages1 <- ceiling(nrow(unique(df[,c("species", "location_name")]))/5)
n_pages_sploc <- ceiling(nrow(unique(df[,c("species", "location_name")]))/6)
n_pages_spp <- ceiling(nrow(unique(df[,c("species")]))/6)
n_pages2 <- ceiling(nrow(unique(df[,c("species")]))/4)
n_pages_months <- ceiling(nrow(unique(df[,c("Month")]))/4)
timediff<-difftime(max(df$Night),min(df$Night), units='days')
timediff
difftime(max(df$Night),min(df$Night), units='days')
difftime(max(df$Night),min(df$Night), units='days')
## Night ~ percentile graph if 2-5 locations + >1 species
#less than or equal to 21 days
if((difftime(max(df$Night),min(df$Night), units='days')<=21) & loc>1 & loc<=5 & spn>1) {
for (i in seq_len(n_pages)) {
print(graph_baseplot(df, "1 week") +
facet_wrap_paginate(species ~ location_name, ncol=2, nrow=4,
scales="fixed", page=i) +
theme(strip.text.x = element_text(size=12, face="italic"),
strip.text.y = element_text(size=12)))
}
}
## this is the function that plots out the base plot for the night-percentile graphs. So you just need to enter what the dataframe and breaks are, e.g. graph_baseplot(data, "1 week")
graph_baseplot = function (df, breaks) {
graph_base <- ggplot(df, aes(x= Night, y= percentile)) +
geom_point(df, size=3, shape=1,
mapping = aes(x=Night, y= percentile,
color=activity_level))+
ylab("Activity Level (Percentile)\n") +
scale_colour_manual(values=cbbPalette, name="Activity\nLevel",
breaks=c("High","Moderate/High","Moderate",
"Low/Moderate","Low")) +
scale_y_continuous(breaks=seq(0,100,20), limits=c(0,100)) +
scale_x_date(name = "\nNight", date_breaks = breaks,
date_labels = "%d %b %Y") +
theme_bw() +
theme(panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
panel.border = element_rect(colour="black",
linetype="solid"),
axis.line=element_line(size=0.5, colour="black",
linetype="solid"),
axis.title.x=element_text(size=14),
axis.text.x  = element_text(angle=90,size=12, hjust=1,
vjust=0),
axis.text.y  = element_text(size=12),
axis.line.x = element_line(color="black", size = 0.5),
axis.line.y = element_line(color="black", size = 0.5),
axis.title.y = element_text(size=14)) +
geom_hline(aes(yintercept=20), linetype="dashed",
color="#0072B2") +
geom_hline(aes(yintercept=40), linetype="dashed",
color="#56B4E9") +
geom_hline(aes(yintercept=60), linetype="dashed",
color="#009E73") +
geom_hline(aes(yintercept=80), linetype="dashed",
color="#E69F00")
return(graph_base)
}
## Night ~ percentile graph if 2-5 locations + >1 species
#less than or equal to 21 days
if((difftime(max(df$Night),min(df$Night), units='days')<=21) & loc>1 & loc<=5 & spn>1) {
for (i in seq_len(n_pages)) {
print(graph_baseplot(df, "1 week") +
facet_wrap_paginate(species ~ location_name, ncol=2, nrow=4,
scales="fixed", page=i) +
theme(strip.text.x = element_text(size=12, face="italic"),
strip.text.y = element_text(size=12)))
}
}
## Night ~ percentile graph if 2-5 locations + >1 species
#less than or equal to 21 days
if(((timediff)<=21) & loc>1 & loc<=5 & spn>1)) {
## Night ~ percentile graph if 2-5 locations + >1 species
#less than or equal to 21 days
if(((timediff)<=21) & loc>1 & loc<=5 & spn>1) {
for (i in seq_len(n_pages)) {
print(graph_baseplot(df, "1 week") +
facet_wrap_paginate(species ~ location_name, ncol=2, nrow=4,
scales="fixed", page=i) +
theme(strip.text.x = element_text(size=12, face="italic"),
strip.text.y = element_text(size=12)))
}
}
## Night ~ percentile graph if 2-5 locations + >1 species
#less than or equal to 21 days
if(timediff<=21 & loc>1 & loc<=5 & spn>1) {
for (i in seq_len(n_pages)) {
print(graph_baseplot(df, "1 week") +
facet_wrap_paginate(species ~ location_name, ncol=2, nrow=4,
scales="fixed", page=i) +
theme(strip.text.x = element_text(size=12, face="italic"),
strip.text.y = element_text(size=12)))
}
}
## Night ~ percentile graph if >5 location + >1 species
#less than or equal to 21 days
if(timediff<=21 & loc>5 & spn>1) || (timediff<=21 & loc>5 & spn=="1") {
## Night ~ percentile graph if >5 location + >1 species
#less than or equal to 21 days
if((timediff<=21 & loc>5 & spn>1) || (timediff<=21 & loc>5 & spn=="1")) {
for (i in seq_len(n_pages)) {
print(graph_baseplot(df, "3 days") +
facet_wrap_paginate(species ~ location_name, ncol=2,
nrow=4, scales="fixed", page=i) +
theme(strip.text.x = element_text(size=12, face="italic"),
strip.text.y = element_text(size=12)))
}
}
## Night ~ percentile graph if >5 location + >1 species
#less than or equal to 21 days
if((timediff<=21 & loc>1 & loc<=5 & spn>1) || (timediff<=21 & loc>5 & spn>1) || (timediff<=21 & loc>5 & spn=="1")) {
for (i in seq_len(n_pages)) {
print(graph_baseplot(df, "3 days") +
facet_wrap_paginate(species ~ location_name, ncol=2,
nrow=4, scales="fixed", page=i) +
theme(strip.text.x = element_text(size=12, face="italic"),
strip.text.y = element_text(size=12)))
}
}
## Night ~ percentile graph if 2-5 locations + >1 species
#less than or equal to 21 days
if(timediff<=21 & loc>1 & loc<=5 & spn>1) {
for (i in seq_len(n_pages)) {
print(graph_baseplot(df, "3 days") +
facet_wrap_paginate(species ~ location_name, ncol=2, nrow=4,
scales="fixed", page=i) +
theme(strip.text.x = element_text(size=12, face="italic"),
strip.text.y = element_text(size=12)))
}
}
## Night ~ percentile graph if 2-5 locations + >1 species
#if time diff between 50 and 300 days
if((timediff>50 & timediff<=300 & loc>1 & loc<=5 & spn>1) || (timediff>50 & timediff<=300 & loc>5 & spn>1) || (timediff>50 & timediff<=300 & loc>5 & spn=="1"))  {
for (i in seq_len(n_pages)) {
print(graph_baseplot(df, "3 weeks") +
facet_wrap_paginate(species ~ location_name, ncol=2, nrow=4,
scales="fixed", page=i) +
theme(strip.text.x = element_text(size=12, face="italic"),
strip.text.y = element_text(size=12)))
}
}
timediff_meds <- difftime(max(medians$Night),min(medians$Night), units='days')
# get the site-wide medians
df$percentiles <- as.numeric(df$percentile)
medians <- df %>%
dplyr::select(location_name, Night, Spp, percentiles,
activity_level, species) %>%
dplyr::group_by(Night, Spp) %>%
dplyr::mutate(med = median(percentiles)) %>%
dplyr::arrange(Night)
# definte difftime for the medians dataframe to be used for plotting graphs
timediff_meds <- difftime(max(medians$Night),min(medians$Night), units='days')
timediff_meds
# if there is one location create the first graph
# else, create the base_boxplot graph from the above function
if(loc=="1") {
boxplot1 <- ggplot(df, aes(x=Spp, y=percentile)) +
geom_hline(aes(yintercept=0), linetype="dashed",
color="#000000") +
geom_hline(aes(yintercept=20), linetype="dashed",
color="#0072B2") +
geom_hline(aes(yintercept=40), linetype="dashed",
color="#56B4E9") +
geom_hline(aes(yintercept=60), linetype="dashed",
color="#009E73") +
geom_hline(aes(yintercept=80), linetype="dashed",
color="#E69F00") +
geom_boxplot(df, mapping = aes(fill=species)) +
xlab("\nSpecies") +
ylab("Activity Level (Percentile)\n") +
scale_fill_grey(start = 0.35, end = 1) +
scale_x_discrete(drop=TRUE) +
scale_y_continuous(breaks=seq(0,100,20)) +
expand_limits(y=c(0,100)) +
theme_bw() +
theme(panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
panel.border = element_rect(linetype="blank"),
axis.line=element_line(size=0.5, colour="black",
linetype="solid"),
axis.title.x=element_text(size=14),
axis.text.x  = element_text(angle=90, face="italic",
size=12, hjust=1, vjust=0),
axis.text.y  = element_text(size=12),
axis.line.x = element_line(color="black", size = 0.5),
axis.line.y = element_line(color="black", size = 0.5),
axis.title.y=element_text(size=14),
legend.position="none")
boxplot1
} else {
for (i in seq_len(n_pages2)) {
print(box_baseplot(df, species)) }
}
## this is the ggplot code for the boxplots if there is more than location / detector identity - it's saved as a function so any additions to it in the function that require a specific if statement can be written as:
# box_basplot (df) + xxxx
## the for statement plots the graphs over multiple pages using facet_grid/wrap_paginate otherwise they're too squashed up. "wrap" will create lots of separate graphs with the header at the top (most frequently used here), "grid" creates a grid of the graphs with the title on the right y axis.
box_baseplot = function (df, facet) {
ggplot(df, aes(x=location_name, y=percentile)) +
geom_hline(aes(yintercept=0), linetype="dashed",
color="#000000") +
geom_hline(aes(yintercept=20), linetype="dashed",
color="#0072B2") +
geom_hline(aes(yintercept=40), linetype="dashed",
color="#56B4E9") +
geom_hline(aes(yintercept=60), linetype="dashed",
color="#009E73") +
geom_hline(aes(yintercept=80), linetype="dashed",
color="#E69F00") +
geom_boxplot(df, mapping = aes(fill=location_name)) +
xlab("\nDetector ID") +
ylab("Activity Level (Percentile)\n") +
scale_fill_grey(start = 0.35, end = 1) +
scale_x_discrete(drop=FALSE) +
scale_y_continuous(breaks=seq(0,100,20), limits=c(0,100)) +
expand_limits(y=c(0,100)) +
theme_bw() +
theme(panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
panel.border = element_rect(colour="black",
linetype="solid"),
axis.line=element_line(size=0.5, colour="black",
linetype="solid"),
axis.title.x=element_text(size=14),
axis.text.x  = element_text(angle=90,
size=12, hjust=1, vjust=0),
axis.text.y  = element_text(size=12),
axis.line.x = element_line(color="black", size = 0.5),
axis.line.y = element_line(color="black", size = 0.5),
axis.title.y=element_text(size=14),
legend.position="none") +
facet_grid_paginate(facet ~ ., ncol=1, nrow=4,
scales="fixed", page=i) +
theme(strip.text.y = element_text(size=12, face="italic"))
}
# if there is one location create the first graph
# else, create the base_boxplot graph from the above function
if(loc=="1") {
boxplot1 <- ggplot(df, aes(x=Spp, y=percentile)) +
geom_hline(aes(yintercept=0), linetype="dashed",
color="#000000") +
geom_hline(aes(yintercept=20), linetype="dashed",
color="#0072B2") +
geom_hline(aes(yintercept=40), linetype="dashed",
color="#56B4E9") +
geom_hline(aes(yintercept=60), linetype="dashed",
color="#009E73") +
geom_hline(aes(yintercept=80), linetype="dashed",
color="#E69F00") +
geom_boxplot(df, mapping = aes(fill=species)) +
xlab("\nSpecies") +
ylab("Activity Level (Percentile)\n") +
scale_fill_grey(start = 0.35, end = 1) +
scale_x_discrete(drop=TRUE) +
scale_y_continuous(breaks=seq(0,100,20)) +
expand_limits(y=c(0,100)) +
theme_bw() +
theme(panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
panel.border = element_rect(linetype="blank"),
axis.line=element_line(size=0.5, colour="black",
linetype="solid"),
axis.title.x=element_text(size=14),
axis.text.x  = element_text(angle=90, face="italic",
size=12, hjust=1, vjust=0),
axis.text.y  = element_text(size=12),
axis.line.x = element_line(color="black", size = 0.5),
axis.line.y = element_line(color="black", size = 0.5),
axis.title.y=element_text(size=14),
legend.position="none")
boxplot1
} else {
for (i in seq_len(n_pages2)) {
print(box_baseplot(df, species)) }
}
## this is the ggplot code for the boxplots if there is more than location / detector identity - it's saved as a function so any additions to it in the function that require a specific if statement can be written as:
# box_basplot (df) + xxxx
## the for statement plots the graphs over multiple pages using facet_grid/wrap_paginate otherwise they're too squashed up. "wrap" will create lots of separate graphs with the header at the top (most frequently used here), "grid" creates a grid of the graphs with the title on the right y axis.
box_baseplot = function (df) {
for (i in seq_len(n_pages2)) {
print(ggplot(df, aes(x=location_name, y=percentile)) +
geom_hline(aes(yintercept=0), linetype="dashed",
color="#000000") +
geom_hline(aes(yintercept=20), linetype="dashed",
color="#0072B2") +
geom_hline(aes(yintercept=40), linetype="dashed",
color="#56B4E9") +
geom_hline(aes(yintercept=60), linetype="dashed",
color="#009E73") +
geom_hline(aes(yintercept=80), linetype="dashed",
color="#E69F00") +
geom_boxplot(df, mapping = aes(fill=location_name)) +
xlab("\nDetector ID") +
ylab("Activity Level (Percentile)\n") +
scale_fill_grey(start = 0.35, end = 1) +
scale_x_discrete(drop=FALSE) +
scale_y_continuous(breaks=seq(0,100,20), limits=c(0,100)) +
expand_limits(y=c(0,100)) +
theme_bw() +
theme(panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
panel.border = element_rect(colour="black",
linetype="solid"),
axis.line=element_line(size=0.5, colour="black",
linetype="solid"),
axis.title.x=element_text(size=14),
axis.text.x  = element_text(angle=90,
size=12, hjust=1, vjust=0),
axis.text.y  = element_text(size=12),
axis.line.x = element_line(color="black", size = 0.5),
axis.line.y = element_line(color="black", size = 0.5),
axis.title.y=element_text(size=14),
legend.position="none") +
facet_grid_paginate(species ~ ., ncol=1, nrow=4,
scales="fixed", page=i) +
theme(strip.text.y = element_text(size=12, face="italic")))
}
}
# if there is one location create the first graph
# else, create the base_boxplot graph from the above function
if(loc=="1") {
boxplot1 <- ggplot(df, aes(x=Spp, y=percentile)) +
geom_hline(aes(yintercept=0), linetype="dashed",
color="#000000") +
geom_hline(aes(yintercept=20), linetype="dashed",
color="#0072B2") +
geom_hline(aes(yintercept=40), linetype="dashed",
color="#56B4E9") +
geom_hline(aes(yintercept=60), linetype="dashed",
color="#009E73") +
geom_hline(aes(yintercept=80), linetype="dashed",
color="#E69F00") +
geom_boxplot(df, mapping = aes(fill=species)) +
xlab("\nSpecies") +
ylab("Activity Level (Percentile)\n") +
scale_fill_grey(start = 0.35, end = 1) +
scale_x_discrete(drop=TRUE) +
scale_y_continuous(breaks=seq(0,100,20)) +
expand_limits(y=c(0,100)) +
theme_bw() +
theme(panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
panel.border = element_rect(linetype="blank"),
axis.line=element_line(size=0.5, colour="black",
linetype="solid"),
axis.title.x=element_text(size=14),
axis.text.x  = element_text(angle=90, face="italic",
size=12, hjust=1, vjust=0),
axis.text.y  = element_text(size=12),
axis.line.x = element_line(color="black", size = 0.5),
axis.line.y = element_line(color="black", size = 0.5),
axis.title.y=element_text(size=14),
legend.position="none")
boxplot1
} else {
box_baseplot(df)
}
